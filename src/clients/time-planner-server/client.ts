/**
 * Generated by orval v6.18.1 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  ErrorMessage,
  UserInfoDTO,
  TaskDTO,
  GetTasksParams,
  CreateTaskDTO,
  ProjectDTO,
  CreateProjectDTO,
  ScheduleInfoDTO,
  BannedRangeDTO,
  CreateBannedRangeDTO,
  UpdateTaskDTO,
  UpdateProjectDTO,
  Links200One,
  Links200Two,
  Links200Three,
  Health200One,
  Health200Two,
  Health200Three,
  HealthPath200One,
  HealthPath200Two,
  HealthPath200Three
} from './model'
import { customInstance } from '../../../config/axios-instance';



// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * @summary Get tasks order
 */
export const getTasksDayOrder = (
    day: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/day/${day}/tasks/order`, method: 'get', signal
    },
      options);
    }
  

export const getGetTasksDayOrderQueryKey = (day: string,) => {
    
    return [`/day/${day}/tasks/order`] as const;
    }
  

    
export const getGetTasksDayOrderQueryOptions = <TData = Awaited<ReturnType<typeof getTasksDayOrder>>, TError = ErrorMessage>(day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTasksDayOrder>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTasksDayOrderQueryKey(day);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasksDayOrder>>> = ({ signal }) => getTasksDayOrder(day, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(day), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTasksDayOrder>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTasksDayOrderQueryResult = NonNullable<Awaited<ReturnType<typeof getTasksDayOrder>>>
export type GetTasksDayOrderQueryError = ErrorMessage

/**
 * @summary Get tasks order
 */
export const useGetTasksDayOrder = <TData = Awaited<ReturnType<typeof getTasksDayOrder>>, TError = ErrorMessage>(
 day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTasksDayOrder>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTasksDayOrderQueryOptions(day,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update tasks order
 */
export const updateTasksDayOrder = (
    day: string,
    updateTasksDayOrderBody: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<string[]>(
      {url: `/day/${day}/tasks/order`, method: 'put',
      headers: {'Content-Type': 'application/json', },
      data: updateTasksDayOrderBody
    },
      options);
    }
  


export const getUpdateTasksDayOrderMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTasksDayOrder>>, TError,{day: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTasksDayOrder>>, TError,{day: string;data: string[]}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTasksDayOrder>>, {day: string;data: string[]}> = (props) => {
          const {day,data} = props ?? {};

          return  updateTasksDayOrder(day,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateTasksDayOrderMutationResult = NonNullable<Awaited<ReturnType<typeof updateTasksDayOrder>>>
    export type UpdateTasksDayOrderMutationBody = string[]
    export type UpdateTasksDayOrderMutationError = ErrorMessage

    /**
 * @summary Update tasks order
 */
export const useUpdateTasksDayOrder = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTasksDayOrder>>, TError,{day: string;data: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getUpdateTasksDayOrderMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const initializeUser = (
    
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserInfoDTO>(
      {url: `/user/initialize`, method: 'post'
    },
      options);
    }
  


export const getInitializeUserMutationOptions = <TError = ErrorMessage,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeUser>>, TError,TVariables, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof initializeUser>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeUser>>, TVariables> = () => {
          

          return  initializeUser(requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type InitializeUserMutationResult = NonNullable<Awaited<ReturnType<typeof initializeUser>>>
    
    export type InitializeUserMutationError = ErrorMessage

    export const useInitializeUser = <TError = ErrorMessage,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeUser>>, TError,TVariables, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getInitializeUserMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get tasks
 */
export const getTasks = (
    params: GetTasksParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TaskDTO[]>(
      {url: `/tasks`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getGetTasksQueryKey = (params: GetTasksParams,) => {
    
    return [`/tasks`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetTasksQueryOptions = <TData = Awaited<ReturnType<typeof getTasks>>, TError = ErrorMessage>(params: GetTasksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTasksQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTasks>>> = ({ signal }) => getTasks(params, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getTasks>>>
export type GetTasksQueryError = ErrorMessage

/**
 * @summary Get tasks
 */
export const useGetTasks = <TData = Awaited<ReturnType<typeof getTasks>>, TError = ErrorMessage>(
 params: GetTasksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTasksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const createTask = (
    createTaskDTO: CreateTaskDTO,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<TaskDTO>(
      {url: `/tasks`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createTaskDTO
    },
      options);
    }
  


export const getCreateTaskMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskDTO}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTask>>, {data: CreateTaskDTO}> = (props) => {
          const {data} = props ?? {};

          return  createTask(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof createTask>>>
    export type CreateTaskMutationBody = CreateTaskDTO
    export type CreateTaskMutationError = ErrorMessage

    export const useCreateTask = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTask>>, TError,{data: CreateTaskDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getCreateTaskMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get projects
 */
export const getProjects = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectDTO[]>(
      {url: `/projects`, method: 'get', signal
    },
      options);
    }
  

export const getGetProjectsQueryKey = () => {
    
    return [`/projects`] as const;
    }
  

    
export const getGetProjectsQueryOptions = <TData = Awaited<ReturnType<typeof getProjects>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectsQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjects>>> = ({ signal }) => getProjects(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getProjects>>>
export type GetProjectsQueryError = ErrorMessage

/**
 * @summary Get projects
 */
export const useGetProjects = <TData = Awaited<ReturnType<typeof getProjects>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjects>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const createProject = (
    createProjectDTO: CreateProjectDTO,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<ProjectDTO>(
      {url: `/projects`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createProjectDTO
    },
      options);
    }
  


export const getCreateProjectMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectDTO}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProject>>, {data: CreateProjectDTO}> = (props) => {
          const {data} = props ?? {};

          return  createProject(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof createProject>>>
    export type CreateProjectMutationBody = CreateProjectDTO
    export type CreateProjectMutationError = ErrorMessage

    export const useCreateProject = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProject>>, TError,{data: CreateProjectDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getCreateProjectMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get day's auto schedule info
 */
export const getAutoScheduleInfo = (
    day: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ScheduleInfoDTO>(
      {url: `/day/${day}/tasks/schedule`, method: 'get', signal
    },
      options);
    }
  

export const getGetAutoScheduleInfoQueryKey = (day: string,) => {
    
    return [`/day/${day}/tasks/schedule`] as const;
    }
  

    
export const getGetAutoScheduleInfoQueryOptions = <TData = Awaited<ReturnType<typeof getAutoScheduleInfo>>, TError = ErrorMessage>(day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAutoScheduleInfo>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAutoScheduleInfoQueryKey(day);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAutoScheduleInfo>>> = ({ signal }) => getAutoScheduleInfo(day, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(day), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAutoScheduleInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAutoScheduleInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getAutoScheduleInfo>>>
export type GetAutoScheduleInfoQueryError = ErrorMessage

/**
 * @summary Get day's auto schedule info
 */
export const useGetAutoScheduleInfo = <TData = Awaited<ReturnType<typeof getAutoScheduleInfo>>, TError = ErrorMessage>(
 day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAutoScheduleInfo>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAutoScheduleInfoQueryOptions(day,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Run automatically assign startTime to all tasks assigned to selected day
 */
export const schedule = (
    day: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/day/${day}/tasks/schedule`, method: 'post'
    },
      options);
    }
  


export const getScheduleMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof schedule>>, TError,{day: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof schedule>>, TError,{day: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof schedule>>, {day: string}> = (props) => {
          const {day} = props ?? {};

          return  schedule(day,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type ScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof schedule>>>
    
    export type ScheduleMutationError = ErrorMessage

    /**
 * @summary Run automatically assign startTime to all tasks assigned to selected day
 */
export const useSchedule = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof schedule>>, TError,{day: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getScheduleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const revokeSchedule = (
    day: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/day/${day}/tasks/schedule`, method: 'delete'
    },
      options);
    }
  


export const getRevokeScheduleMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revokeSchedule>>, TError,{day: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof revokeSchedule>>, TError,{day: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof revokeSchedule>>, {day: string}> = (props) => {
          const {day} = props ?? {};

          return  revokeSchedule(day,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type RevokeScheduleMutationResult = NonNullable<Awaited<ReturnType<typeof revokeSchedule>>>
    
    export type RevokeScheduleMutationError = ErrorMessage

    export const useRevokeSchedule = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof revokeSchedule>>, TError,{day: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getRevokeScheduleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get banned ranges
 */
export const getBannedRanges = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BannedRangeDTO[]>(
      {url: `/bannedRanges`, method: 'get', signal
    },
      options);
    }
  

export const getGetBannedRangesQueryKey = () => {
    
    return [`/bannedRanges`] as const;
    }
  

    
export const getGetBannedRangesQueryOptions = <TData = Awaited<ReturnType<typeof getBannedRanges>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBannedRanges>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBannedRangesQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBannedRanges>>> = ({ signal }) => getBannedRanges(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBannedRanges>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBannedRangesQueryResult = NonNullable<Awaited<ReturnType<typeof getBannedRanges>>>
export type GetBannedRangesQueryError = ErrorMessage

/**
 * @summary Get banned ranges
 */
export const useGetBannedRanges = <TData = Awaited<ReturnType<typeof getBannedRanges>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBannedRanges>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetBannedRangesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const createBannedRange = (
    createBannedRangeDTO: CreateBannedRangeDTO,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<BannedRangeDTO>(
      {url: `/bannedRanges`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: createBannedRangeDTO
    },
      options);
    }
  


export const getCreateBannedRangeMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBannedRange>>, TError,{data: CreateBannedRangeDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createBannedRange>>, TError,{data: CreateBannedRangeDTO}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBannedRange>>, {data: CreateBannedRangeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createBannedRange(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateBannedRangeMutationResult = NonNullable<Awaited<ReturnType<typeof createBannedRange>>>
    export type CreateBannedRangeMutationBody = CreateBannedRangeDTO
    export type CreateBannedRangeMutationError = ErrorMessage

    export const useCreateBannedRange = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBannedRange>>, TError,{data: CreateBannedRangeDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getCreateBannedRangeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const getTask = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TaskDTO>(
      {url: `/tasks/${id}`, method: 'get', signal
    },
      options);
    }
  

export const getGetTaskQueryKey = (id: string,) => {
    
    return [`/tasks/${id}`] as const;
    }
  

    
export const getGetTaskQueryOptions = <TData = Awaited<ReturnType<typeof getTask>>, TError = ErrorMessage>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) => getTask(id, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>
export type GetTaskQueryError = ErrorMessage

export const useGetTask = <TData = Awaited<ReturnType<typeof getTask>>, TError = ErrorMessage>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTaskQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const deleteTask = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/tasks/${id}`, method: 'delete'
    },
      options);
    }
  


export const getDeleteTaskMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTask>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTask>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTask>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteTask(id,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteTaskMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTask>>>
    
    export type DeleteTaskMutationError = ErrorMessage

    export const useDeleteTask = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTask>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getDeleteTaskMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const updateTask = (
    id: string,
    updateTaskDTO: UpdateTaskDTO,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<TaskDTO>(
      {url: `/tasks/${id}`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: updateTaskDTO
    },
      options);
    }
  


export const getUpdateTaskMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTask>>, TError,{id: string;data: UpdateTaskDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTask>>, TError,{id: string;data: UpdateTaskDTO}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTask>>, {id: string;data: UpdateTaskDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateTask(id,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof updateTask>>>
    export type UpdateTaskMutationBody = UpdateTaskDTO
    export type UpdateTaskMutationError = ErrorMessage

    export const useUpdateTask = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTask>>, TError,{id: string;data: UpdateTaskDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getUpdateTaskMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const getProject = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ProjectDTO>(
      {url: `/projects/${id}`, method: 'get', signal
    },
      options);
    }
  

export const getGetProjectQueryKey = (id: string,) => {
    
    return [`/projects/${id}`] as const;
    }
  

    
export const getGetProjectQueryOptions = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorMessage>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({ signal }) => getProject(id, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectQueryResult = NonNullable<Awaited<ReturnType<typeof getProject>>>
export type GetProjectQueryError = ErrorMessage

export const useGetProject = <TData = Awaited<ReturnType<typeof getProject>>, TError = ErrorMessage>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const deleteProject = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/projects/${id}`, method: 'delete'
    },
      options);
    }
  


export const getDeleteProjectMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProject>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteProject(id,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteProjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProject>>>
    
    export type DeleteProjectMutationError = ErrorMessage

    export const useDeleteProject = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProject>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getDeleteProjectMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const updateProject = (
    id: string,
    updateProjectDTO: UpdateProjectDTO,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<ProjectDTO>(
      {url: `/projects/${id}`, method: 'patch',
      headers: {'Content-Type': 'application/json', },
      data: updateProjectDTO
    },
      options);
    }
  


export const getUpdateProjectMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: string;data: UpdateProjectDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: string;data: UpdateProjectDTO}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProject>>, {id: string;data: UpdateProjectDTO}> = (props) => {
          const {id,data} = props ?? {};

          return  updateProject(id,data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateProjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateProject>>>
    export type UpdateProjectMutationBody = UpdateProjectDTO
    export type UpdateProjectMutationError = ErrorMessage

    export const useUpdateProject = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProject>>, TError,{id: string;data: UpdateProjectDTO}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getUpdateProjectMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
export const validate = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<boolean>(
      {url: `/validateAuth`, method: 'get', signal
    },
      options);
    }
  

export const getValidateQueryKey = () => {
    
    return [`/validateAuth`] as const;
    }
  

    
export const getValidateQueryOptions = <TData = Awaited<ReturnType<typeof validate>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validate>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validate>>> = ({ signal }) => validate(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validate>>, TError, TData> & { queryKey: QueryKey }
}

export type ValidateQueryResult = NonNullable<Awaited<ReturnType<typeof validate>>>
export type ValidateQueryError = ErrorMessage

export const useValidate = <TData = Awaited<ReturnType<typeof validate>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validate>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidateQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Get user info
 */
export const getUserInfo = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserInfoDTO>(
      {url: `/user`, method: 'get', signal
    },
      options);
    }
  

export const getGetUserInfoQueryKey = () => {
    
    return [`/user`] as const;
    }
  

    
export const getGetUserInfoQueryOptions = <TData = Awaited<ReturnType<typeof getUserInfo>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserInfoQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfo>>> = ({ signal }) => getUserInfo(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getUserInfo>>>
export type GetUserInfoQueryError = ErrorMessage

/**
 * @summary Get user info
 */
export const useGetUserInfo = <TData = Awaited<ReturnType<typeof getUserInfo>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserInfoQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Get project tasks
 */
export const getProjectTasks = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TaskDTO[]>(
      {url: `/projects/${id}/tasks`, method: 'get', signal
    },
      options);
    }
  

export const getGetProjectTasksQueryKey = (id: string,) => {
    
    return [`/projects/${id}/tasks`] as const;
    }
  

    
export const getGetProjectTasksQueryOptions = <TData = Awaited<ReturnType<typeof getProjectTasks>>, TError = ErrorMessage>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProjectTasksQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectTasks>>> = ({ signal }) => getProjectTasks(id, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetProjectTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getProjectTasks>>>
export type GetProjectTasksQueryError = ErrorMessage

/**
 * @summary Get project tasks
 */
export const useGetProjectTasks = <TData = Awaited<ReturnType<typeof getProjectTasks>>, TError = ErrorMessage>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getProjectTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetProjectTasksQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Get day's tasks
 */
export const getDayTasks = (
    day: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TaskDTO[]>(
      {url: `/day/${day}/tasks`, method: 'get', signal
    },
      options);
    }
  

export const getGetDayTasksQueryKey = (day: string,) => {
    
    return [`/day/${day}/tasks`] as const;
    }
  

    
export const getGetDayTasksQueryOptions = <TData = Awaited<ReturnType<typeof getDayTasks>>, TError = ErrorMessage>(day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDayTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDayTasksQueryKey(day);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDayTasks>>> = ({ signal }) => getDayTasks(day, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(day), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDayTasks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetDayTasksQueryResult = NonNullable<Awaited<ReturnType<typeof getDayTasks>>>
export type GetDayTasksQueryError = ErrorMessage

/**
 * @summary Get day's tasks
 */
export const useGetDayTasks = <TData = Awaited<ReturnType<typeof getDayTasks>>, TError = ErrorMessage>(
 day: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getDayTasks>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetDayTasksQueryOptions(day,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getBannedRange = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BannedRangeDTO>(
      {url: `/bannedRanges/${id}`, method: 'get', signal
    },
      options);
    }
  

export const getGetBannedRangeQueryKey = (id: string,) => {
    
    return [`/bannedRanges/${id}`] as const;
    }
  

    
export const getGetBannedRangeQueryOptions = <TData = Awaited<ReturnType<typeof getBannedRange>>, TError = ErrorMessage>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBannedRange>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBannedRangeQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBannedRange>>> = ({ signal }) => getBannedRange(id, requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBannedRange>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBannedRangeQueryResult = NonNullable<Awaited<ReturnType<typeof getBannedRange>>>
export type GetBannedRangeQueryError = ErrorMessage

export const useGetBannedRange = <TData = Awaited<ReturnType<typeof getBannedRange>>, TError = ErrorMessage>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBannedRange>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetBannedRangeQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const deleteBannedRange = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/bannedRanges/${id}`, method: 'delete'
    },
      options);
    }
  


export const getDeleteBannedRangeMutationOptions = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBannedRange>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBannedRange>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBannedRange>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteBannedRange(id,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteBannedRangeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBannedRange>>>
    
    export type DeleteBannedRangeMutationError = ErrorMessage

    export const useDeleteBannedRange = <TError = ErrorMessage,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBannedRange>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getDeleteBannedRangeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Actuator root web endpoint
 */
export const links = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Links200One | Links200Two | Links200Three>(
      {url: `/actuator`, method: 'get', signal
    },
      options);
    }
  

export const getLinksQueryKey = () => {
    
    return [`/actuator`] as const;
    }
  

    
export const getLinksQueryOptions = <TData = Awaited<ReturnType<typeof links>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof links>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLinksQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof links>>> = ({ signal }) => links(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof links>>, TError, TData> & { queryKey: QueryKey }
}

export type LinksQueryResult = NonNullable<Awaited<ReturnType<typeof links>>>
export type LinksQueryError = ErrorMessage

/**
 * @summary Actuator root web endpoint
 */
export const useLinks = <TData = Awaited<ReturnType<typeof links>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof links>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLinksQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Actuator web endpoint 'health'
 */
export const health = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Health200One | Health200Two | Health200Three>(
      {url: `/actuator/health`, method: 'get', signal
    },
      options);
    }
  

export const getHealthQueryKey = () => {
    
    return [`/actuator/health`] as const;
    }
  

    
export const getHealthQueryOptions = <TData = Awaited<ReturnType<typeof health>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({ signal }) => health(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>
export type HealthQueryError = ErrorMessage

/**
 * @summary Actuator web endpoint 'health'
 */
export const useHealth = <TData = Awaited<ReturnType<typeof health>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHealthQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Actuator web endpoint 'health-path'
 */
export const healthPath = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<HealthPath200One | HealthPath200Two | HealthPath200Three>(
      {url: `/actuator/health/**`, method: 'get', signal
    },
      options);
    }
  

export const getHealthPathQueryKey = () => {
    
    return [`/actuator/health/**`] as const;
    }
  

    
export const getHealthPathQueryOptions = <TData = Awaited<ReturnType<typeof healthPath>>, TError = ErrorMessage>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthPath>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {
    
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthPathQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthPath>>> = ({ signal }) => healthPath(requestOptions, signal);

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthPath>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthPathQueryResult = NonNullable<Awaited<ReturnType<typeof healthPath>>>
export type HealthPathQueryError = ErrorMessage

/**
 * @summary Actuator web endpoint 'health-path'
 */
export const useHealthPath = <TData = Awaited<ReturnType<typeof healthPath>>, TError = ErrorMessage>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthPath>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHealthPathQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


